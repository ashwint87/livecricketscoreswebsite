{"ast":null,"code":"var _jsxFileName = \"/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/SeriesRangesContext.js\nimport React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeriesRangesContext = /*#__PURE__*/createContext({\n  seriesRows: [],\n  loadingSeriesRows: true\n});\nexport const useSeriesRanges = () => {\n  _s();\n  return useContext(SeriesRangesContext);\n};\n\n/** Cache */\n_s(useSeriesRanges, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = sid => `series_range_${sid}`;\n_c = CK;\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\nconst extendEndForSeriesCode = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\nexport function SeriesRangesProvider({\n  children\n}) {\n  _s2();\n  const {\n    allSeries,\n    loading\n  } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map of stageId -> series base item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional list (no network) */\n  const provisionalRows = useMemo(() => {\n    if (!(allSeries !== null && allSeries !== void 0 && allSeries.length)) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // infer includeNext (fast guess), will be validated during hydration\n      const code = String(s.code || '').toUpperCase();\n      const includeNext = !!next && Number(next.league_id) === Number(s.league_id) && Number(next.season_id) === Number(s.season_id) && !FORMAT_CODES.includes(code);\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      // derive provisional range from series dates\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO = (last === null || last === void 0 ? void 0 : last.end_date) || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const endISO = extendEndForSeriesCode(endBaseISO, last === null || last === void 0 ? void 0 : last.code) || endBaseISO;\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate: startISO ? new Date(startISO) : null,\n        endDate: endISO ? new Date(endISO) : null\n      });\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Dedup: keep one row per firstStageId (fast and safe)\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);else {\n        // prefer the one with a non-null start or end\n        const cur = uniq.get(r.firstStageId);\n        const better = !cur.startDate && r.startDate || !cur.endDate && r.endDate ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n    const list = Array.from(uniq.values()).sort((a, b) => {\n      var _a$startDate, _b$startDate;\n      return (((_a$startDate = a.startDate) === null || _a$startDate === void 0 ? void 0 : _a$startDate.getTime()) || 0) - (((_b$startDate = b.startDate) === null || _b$startDate === void 0 ? void 0 : _b$startDate.getTime()) || 0);\n    });\n    return list;\n  }, [allSeries, stageMap]);\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) show provisional instantly\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) hydrate precisely using /api/stages/:sid (+1) like the tab\n    const now = Date.now();\n    const readCache = sid => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), {\n          data: parsed.data,\n          exp: parsed.exp\n        });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n    const writeCache = (sid, data) => {\n      const rec = {\n        data,\n        exp: now + TTL_MS\n      };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n    const tasks = provisionalRows.map(row => async () => {\n      var _stageRes$value$data, _stageRes$value$data$, _nextStageRes$value$d, _nextStageRes$value$d2;\n      const sid = row.firstStageId;\n\n      // cache hit?\n      const cached = readCache(sid);\n      if (cached !== null && cached !== void 0 && cached.startDate && cached !== null && cached !== void 0 && cached.endDate && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n          ...r,\n          stage_ids: cached.stageIdsToUse,\n          startDate: cached.startDate ? new Date(cached.startDate) : null,\n          endDate: cached.endDate ? new Date(cached.endDate) : null\n        } : r));\n        return;\n      }\n\n      // fetch stage + (maybe) stage+1 meta EXACTLY like the tab\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([axios.get(`/api/stages/${sid}`, {\n        signal: controller.signal\n      }), axios.get(`/api/stages/${nextId}`, {\n        signal: controller.signal\n      })]);\n      const stage = stageRes.status === 'fulfilled' ? (_stageRes$value$data = stageRes.value.data) === null || _stageRes$value$data === void 0 ? void 0 : (_stageRes$value$data$ = _stageRes$value$data.data) === null || _stageRes$value$data$ === void 0 ? void 0 : _stageRes$value$data$.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? (_nextStageRes$value$d = nextStageRes.value.data) === null || _nextStageRes$value$d === void 0 ? void 0 : (_nextStageRes$value$d2 = _nextStageRes$value$d.data) === null || _nextStageRes$value$d2 === void 0 ? void 0 : _nextStageRes$value$d2.data : null;\n      const includeNext = stage && nextStage && Number(stage.league_id) === Number(nextStage.league_id) && Number(stage.season_id) === Number(nextStage.season_id) && !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // fetch matches for decided stage set\n      const matchResults = await Promise.allSettled(stageIdsToUse.map(id => axios.get(`/api/series/${id}/matches`, {\n        signal: controller.signal\n      })));\n      const matches = matchResults.flatMap(r => {\n        var _r$value$data, _r$value$data$data;\n        return r.status === 'fulfilled' ? ((_r$value$data = r.value.data) === null || _r$value$data === void 0 ? void 0 : (_r$value$data$data = _r$value$data.data) === null || _r$value$data$data === void 0 ? void 0 : _r$value$data$data.data) || [] : [];\n      });\n      let startDateISO = null;\n      let endDateISO = null;\n      if (matches.length) {\n        matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n        startDateISO = new Date(first.starting_at).toISOString();\n        endDateISO = extendEndForMatchType(last.starting_at, last.type) || new Date(last.starting_at).toISOString();\n      }\n      writeCache(sid, {\n        sid,\n        stageIdsToUse,\n        startDate: startDateISO,\n        endDate: endDateISO\n      });\n      if (cancelled) return;\n      setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n        ...r,\n        stage_ids: stageIdsToUse,\n        startDate: startDateISO ? new Date(startDateISO) : r.startDate,\n        endDate: endDateISO ? new Date(endDateISO) : r.endDate\n      } : r));\n    });\n\n    // high concurrency so hydration finishes quickly\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try {\n            await tasks[idx]();\n          } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n    run();\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n  const value = useMemo(() => ({\n    seriesRows,\n    loadingSeriesRows\n  }), [seriesRows, loadingSeriesRows]);\n  return /*#__PURE__*/_jsxDEV(SeriesRangesContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 278,\n    columnNumber: 5\n  }, this);\n}\n_s2(SeriesRangesProvider, \"wYako18W2h16YVYoLOkLbf+W7DM=\", false, function () {\n  return [useSeries];\n});\n_c2 = SeriesRangesProvider;\nvar _c, _c2;\n$RefreshReg$(_c, \"CK\");\n$RefreshReg$(_c2, \"SeriesRangesProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useRef","useState","axios","useSeries","FORMAT_CODES","jsxDEV","_jsxDEV","SeriesRangesContext","seriesRows","loadingSeriesRows","useSeriesRanges","_s","TTL_MS","CK","sid","_c","extendEndForMatchType","isoStr","type","d","Date","t","String","toUpperCase","setDate","getDate","toISOString","extendEndForSeriesCode","code","c","SeriesRangesProvider","children","_s2","allSeries","loading","setSeriesRows","setLoadingSeriesRows","memCache","Map","stageMap","m","s","Array","isArray","id","Math","min","map","Number","isFinite","set","provisionalRows","length","used","Set","out","sids","from","keys","sort","a","b","has","get","nextId","next","includeNext","league_id","season_id","includes","group","stage_ids","startISO","g","start_date","filter","Boolean","last","endBaseISO","end_date","slice","endISO","push","base","firstStageId","startDate","endDate","add","uniq","r","cur","better","list","values","_a$startDate","_b$startDate","getTime","cancelled","controller","AbortController","now","readCache","inMem","current","exp","data","raw","localStorage","getItem","parsed","JSON","parse","removeItem","writeCache","rec","setItem","stringify","tasks","row","_stageRes$value$data","_stageRes$value$data$","_nextStageRes$value$d","_nextStageRes$value$d2","cached","stageIdsToUse","prev","stageRes","nextStageRes","Promise","allSettled","signal","stage","status","value","nextStage","matchResults","matches","flatMap","_r$value$data","_r$value$data$data","startDateISO","endDateISO","starting_at","first","MAX_CONCURRENT","run","i","runners","fill","idx","all","abort","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js"],"sourcesContent":["// src/context/SeriesRangesContext.js\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\n\nconst SeriesRangesContext = createContext({\n  seriesRows: [],\n  loadingSeriesRows: true,\n});\nexport const useSeriesRanges = () => useContext(SeriesRangesContext);\n\n/** Cache */\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = (sid) => `series_range_${sid}`;\n\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\nconst extendEndForSeriesCode = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\nexport function SeriesRangesProvider({ children }) {\n  const { allSeries, loading } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map of stageId -> series base item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional list (no network) */\n  const provisionalRows = useMemo(() => {\n    if (!allSeries?.length) return [];\n\n    const used = new Set();\n    const out = [];\n\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // infer includeNext (fast guess), will be validated during hydration\n      const code = String(s.code || '').toUpperCase();\n      const includeNext =\n        !!next &&\n        Number(next.league_id) === Number(s.league_id) &&\n        Number(next.season_id) === Number(s.season_id) &&\n        !FORMAT_CODES.includes(code);\n\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      // derive provisional range from series dates\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO = last?.end_date || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const endISO = extendEndForSeriesCode(endBaseISO, last?.code) || endBaseISO;\n\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate: startISO ? new Date(startISO) : null,\n        endDate: endISO ? new Date(endISO) : null,\n      });\n\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Dedup: keep one row per firstStageId (fast and safe)\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);\n      else {\n        // prefer the one with a non-null start or end\n        const cur = uniq.get(r.firstStageId);\n        const better =\n          (!cur.startDate && r.startDate) ||\n          (!cur.endDate && r.endDate) ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n\n    const list = Array.from(uniq.values()).sort(\n      (a, b) => (a.startDate?.getTime() || 0) - (b.startDate?.getTime() || 0)\n    );\n    return list;\n  }, [allSeries, stageMap]);\n\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) show provisional instantly\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) hydrate precisely using /api/stages/:sid (+1) like the tab\n    const now = Date.now();\n\n    const readCache = (sid) => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), { data: parsed.data, exp: parsed.exp });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n\n    const writeCache = (sid, data) => {\n      const rec = { data, exp: now + TTL_MS };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    const tasks = provisionalRows.map((row) => async () => {\n      const sid = row.firstStageId;\n\n      // cache hit?\n      const cached = readCache(sid);\n      if (cached?.startDate && cached?.endDate && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        setSeriesRows((prev) =>\n          prev.map((r) =>\n            r.firstStageId === sid\n              ? {\n                  ...r,\n                  stage_ids: cached.stageIdsToUse,\n                  startDate: cached.startDate ? new Date(cached.startDate) : null,\n                  endDate: cached.endDate ? new Date(cached.endDate) : null,\n                }\n              : r\n          )\n        );\n        return;\n      }\n\n      // fetch stage + (maybe) stage+1 meta EXACTLY like the tab\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([\n        axios.get(`/api/stages/${sid}`, { signal: controller.signal }),\n        axios.get(`/api/stages/${nextId}`, { signal: controller.signal }),\n      ]);\n\n      const stage = stageRes.status === 'fulfilled' ? stageRes.value.data?.data?.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? nextStageRes.value.data?.data?.data : null;\n\n      const includeNext =\n        stage &&\n        nextStage &&\n        Number(stage.league_id) === Number(nextStage.league_id) &&\n        Number(stage.season_id) === Number(nextStage.season_id) &&\n        !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // fetch matches for decided stage set\n      const matchResults = await Promise.allSettled(\n        stageIdsToUse.map((id) => axios.get(`/api/series/${id}/matches`, { signal: controller.signal }))\n      );\n      const matches = matchResults.flatMap((r) =>\n        r.status === 'fulfilled' ? (r.value.data?.data?.data || []) : []\n      );\n\n      let startDateISO = null;\n      let endDateISO = null;\n\n      if (matches.length) {\n        matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n        startDateISO = new Date(first.starting_at).toISOString();\n        endDateISO =\n          extendEndForMatchType(last.starting_at, last.type) ||\n          new Date(last.starting_at).toISOString();\n      }\n\n      writeCache(sid, {\n        sid,\n        stageIdsToUse,\n        startDate: startDateISO,\n        endDate: endDateISO,\n      });\n\n      if (cancelled) return;\n\n      setSeriesRows((prev) =>\n        prev.map((r) =>\n          r.firstStageId === sid\n            ? {\n                ...r,\n                stage_ids: stageIdsToUse,\n                startDate: startDateISO ? new Date(startDateISO) : r.startDate,\n                endDate: endDateISO ? new Date(endDateISO) : r.endDate,\n              }\n            : r\n        )\n      );\n    });\n\n    // high concurrency so hydration finishes quickly\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try { await tasks[idx](); } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n\n    run();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n\n  const value = useMemo(\n    () => ({ seriesRows, loadingSeriesRows }),\n    [seriesRows, loadingSeriesRows]\n  );\n\n  return (\n    <SeriesRangesContext.Provider value={value}>\n      {children}\n    </SeriesRangesContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}