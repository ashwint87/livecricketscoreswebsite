{"ast":null,"code":"var _jsxFileName = \"/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/SeriesRangesContext.js\nimport React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeriesRangesContext = /*#__PURE__*/createContext({\n  seriesRows: [],\n  loadingSeriesRows: true\n});\nexport const useSeriesRanges = () => {\n  _s();\n  return useContext(SeriesRangesContext);\n};\n\n/** Cache */\n_s(useSeriesRanges, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = sid => `series_range_${sid}`;\n\n/** Precise: extend by LAST MATCH type (returns Date) */\n_c = CK;\nconst extendEndForMatchTypeDate = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d;\n};\n\n/** Fast provisional: extend by series code (returns Date) */\nconst extendEndForSeriesCodeDate = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d;\n};\nexport function SeriesRangesProvider({\n  children\n}) {\n  _s2();\n  const {\n    allSeries,\n    loading\n  } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map stageId -> base series item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional rows (instant, no network) */\n  const provisionalRows = useMemo(() => {\n    if (!(allSeries !== null && allSeries !== void 0 && allSeries.length)) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Guess includeNext (validated during hydration)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext = !!next && Number(next.league_id) === Number(s.league_id) && Number(next.season_id) === Number(s.season_id) && !FORMAT_CODES.includes(code);\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO = (last === null || last === void 0 ? void 0 : last.end_date) || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const startDate = startISO ? new Date(startISO) : null;\n      const endDate = endBaseISO ? extendEndForSeriesCodeDate(endBaseISO, last === null || last === void 0 ? void 0 : last.code) || new Date(endBaseISO) : null;\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate,\n        endDate\n      });\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Keep one row per firstStageId\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);else {\n        const cur = uniq.get(r.firstStageId);\n        const better = !cur.startDate && r.startDate || !cur.endDate && r.endDate ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n    const list = Array.from(uniq.values()).sort((a, b) => {\n      var _a$startDate, _b$startDate;\n      return (((_a$startDate = a.startDate) === null || _a$startDate === void 0 ? void 0 : _a$startDate.getTime()) || 0) - (((_b$startDate = b.startDate) === null || _b$startDate === void 0 ? void 0 : _b$startDate.getTime()) || 0);\n    });\n    return list;\n  }, [allSeries, stageMap]);\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly from provisional\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) Hydrate precisely using /api/stages/:sid (+1) and matches\n    const now = Date.now();\n    const readCache = sid => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), {\n          data: parsed.data,\n          exp: parsed.exp\n        });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n    const writeCache = (sid, data) => {\n      const rec = {\n        data,\n        exp: now + TTL_MS\n      };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n    const tasks = provisionalRows.map(row => async () => {\n      var _stageRes$value$data, _stageRes$value$data$, _nextStageRes$value$d, _nextStageRes$value$d2;\n      const sid = row.firstStageId;\n\n      // Cache check (we store timestamps to avoid TZ drift)\n      const cached = readCache(sid);\n      if ((cached === null || cached === void 0 ? void 0 : cached.startMs) != null && (cached === null || cached === void 0 ? void 0 : cached.endMs) != null && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n          ...r,\n          stage_ids: cached.stageIdsToUse,\n          startDate: cached.startMs ? new Date(cached.startMs) : r.startDate,\n          endDate: cached.endMs ? new Date(cached.endMs) : r.endDate\n        } : r));\n        return;\n      }\n\n      // Decide includeNext from real /api/stages (exact as tab)\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([axios.get(`/api/stages/${sid}`, {\n        signal: controller.signal\n      }), axios.get(`/api/stages/${nextId}`, {\n        signal: controller.signal\n      })]);\n      const stage = stageRes.status === 'fulfilled' ? (_stageRes$value$data = stageRes.value.data) === null || _stageRes$value$data === void 0 ? void 0 : (_stageRes$value$data$ = _stageRes$value$data.data) === null || _stageRes$value$data$ === void 0 ? void 0 : _stageRes$value$data$.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? (_nextStageRes$value$d = nextStageRes.value.data) === null || _nextStageRes$value$d === void 0 ? void 0 : (_nextStageRes$value$d2 = _nextStageRes$value$d.data) === null || _nextStageRes$value$d2 === void 0 ? void 0 : _nextStageRes$value$d2.data : null;\n      const includeNext = stage && nextStage && Number(stage.league_id) === Number(nextStage.league_id) && Number(stage.season_id) === Number(nextStage.season_id) && !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // Fetch matches for decided stage(s)\n      const matchResults = await Promise.allSettled(stageIdsToUse.map(id => axios.get(`/api/series/${id}/matches`, {\n        signal: controller.signal\n      })));\n      const matches = matchResults.flatMap(r => {\n        var _r$value$data, _r$value$data$data;\n        return r.status === 'fulfilled' ? ((_r$value$data = r.value.data) === null || _r$value$data === void 0 ? void 0 : (_r$value$data$data = _r$value$data.data) === null || _r$value$data$data === void 0 ? void 0 : _r$value$data$data.data) || [] : [];\n      });\n      let startMs = null;\n      let endMs = null;\n      if (matches.length) {\n        matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n        const startDate = new Date(first.starting_at);\n        const endDateObj = extendEndForMatchTypeDate(last.starting_at, last.type) || new Date(last.starting_at);\n        startMs = startDate.getTime();\n        endMs = endDateObj.getTime();\n      }\n      writeCache(sid, {\n        sid,\n        stageIdsToUse,\n        startMs,\n        endMs\n      });\n      if (cancelled) return;\n      setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n        ...r,\n        stage_ids: stageIdsToUse,\n        startDate: startMs != null ? new Date(startMs) : r.startDate,\n        endDate: endMs != null ? new Date(endMs) : r.endDate\n      } : r));\n    });\n\n    // Run hydration with high concurrency\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try {\n            await tasks[idx]();\n          } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n    run();\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n  const value = useMemo(() => ({\n    seriesRows,\n    loadingSeriesRows\n  }), [seriesRows, loadingSeriesRows]);\n  return /*#__PURE__*/_jsxDEV(SeriesRangesContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 275,\n    columnNumber: 5\n  }, this);\n}\n_s2(SeriesRangesProvider, \"wYako18W2h16YVYoLOkLbf+W7DM=\", false, function () {\n  return [useSeries];\n});\n_c2 = SeriesRangesProvider;\nvar _c, _c2;\n$RefreshReg$(_c, \"CK\");\n$RefreshReg$(_c2, \"SeriesRangesProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useRef","useState","axios","useSeries","FORMAT_CODES","jsxDEV","_jsxDEV","SeriesRangesContext","seriesRows","loadingSeriesRows","useSeriesRanges","_s","TTL_MS","CK","sid","_c","extendEndForMatchTypeDate","isoStr","type","d","Date","t","String","toUpperCase","setDate","getDate","extendEndForSeriesCodeDate","code","c","SeriesRangesProvider","children","_s2","allSeries","loading","setSeriesRows","setLoadingSeriesRows","memCache","Map","stageMap","m","s","Array","isArray","id","Math","min","map","Number","isFinite","set","provisionalRows","length","used","Set","out","sids","from","keys","sort","a","b","has","get","nextId","next","includeNext","league_id","season_id","includes","group","stage_ids","startISO","g","start_date","filter","Boolean","last","endBaseISO","end_date","slice","startDate","endDate","push","base","firstStageId","add","uniq","r","cur","better","list","values","_a$startDate","_b$startDate","getTime","cancelled","controller","AbortController","now","readCache","inMem","current","exp","data","raw","localStorage","getItem","parsed","JSON","parse","removeItem","writeCache","rec","setItem","stringify","tasks","row","_stageRes$value$data","_stageRes$value$data$","_nextStageRes$value$d","_nextStageRes$value$d2","cached","startMs","endMs","stageIdsToUse","prev","stageRes","nextStageRes","Promise","allSettled","signal","stage","status","value","nextStage","matchResults","matches","flatMap","_r$value$data","_r$value$data$data","starting_at","first","endDateObj","MAX_CONCURRENT","run","i","runners","fill","idx","all","abort","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js"],"sourcesContent":["// src/context/SeriesRangesContext.js\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\n\nconst SeriesRangesContext = createContext({\n  seriesRows: [],\n  loadingSeriesRows: true,\n});\nexport const useSeriesRanges = () => useContext(SeriesRangesContext);\n\n/** Cache */\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = (sid) => `series_range_${sid}`;\n\n/** Precise: extend by LAST MATCH type (returns Date) */\nconst extendEndForMatchTypeDate = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d;\n};\n\n/** Fast provisional: extend by series code (returns Date) */\nconst extendEndForSeriesCodeDate = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d;\n};\n\nexport function SeriesRangesProvider({ children }) {\n  const { allSeries, loading } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map stageId -> base series item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional rows (instant, no network) */\n  const provisionalRows = useMemo(() => {\n    if (!allSeries?.length) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Guess includeNext (validated during hydration)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext =\n        !!next &&\n        Number(next.league_id) === Number(s.league_id) &&\n        Number(next.season_id) === Number(s.season_id) &&\n        !FORMAT_CODES.includes(code);\n\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO = last?.end_date || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n\n      const startDate = startISO ? new Date(startISO) : null;\n      const endDate = endBaseISO ? (extendEndForSeriesCodeDate(endBaseISO, last?.code) || new Date(endBaseISO)) : null;\n\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate,\n        endDate,\n      });\n\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Keep one row per firstStageId\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);\n      else {\n        const cur = uniq.get(r.firstStageId);\n        const better =\n          (!cur.startDate && r.startDate) ||\n          (!cur.endDate && r.endDate) ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n\n    const list = Array.from(uniq.values()).sort(\n      (a, b) => (a.startDate?.getTime() || 0) - (b.startDate?.getTime() || 0)\n    );\n    return list;\n  }, [allSeries, stageMap]);\n\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly from provisional\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) Hydrate precisely using /api/stages/:sid (+1) and matches\n    const now = Date.now();\n\n    const readCache = (sid) => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), { data: parsed.data, exp: parsed.exp });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n\n    const writeCache = (sid, data) => {\n      const rec = { data, exp: now + TTL_MS };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    const tasks = provisionalRows.map((row) => async () => {\n      const sid = row.firstStageId;\n\n      // Cache check (we store timestamps to avoid TZ drift)\n      const cached = readCache(sid);\n      if (cached?.startMs != null && cached?.endMs != null && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        setSeriesRows((prev) =>\n          prev.map((r) =>\n            r.firstStageId === sid\n              ? {\n                  ...r,\n                  stage_ids: cached.stageIdsToUse,\n                  startDate: cached.startMs ? new Date(cached.startMs) : r.startDate,\n                  endDate: cached.endMs ? new Date(cached.endMs) : r.endDate,\n                }\n              : r\n          )\n        );\n        return;\n      }\n\n      // Decide includeNext from real /api/stages (exact as tab)\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([\n        axios.get(`/api/stages/${sid}`, { signal: controller.signal }),\n        axios.get(`/api/stages/${nextId}`, { signal: controller.signal }),\n      ]);\n\n      const stage = stageRes.status === 'fulfilled' ? stageRes.value.data?.data?.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? nextStageRes.value.data?.data?.data : null;\n\n      const includeNext =\n        stage &&\n        nextStage &&\n        Number(stage.league_id) === Number(nextStage.league_id) &&\n        Number(stage.season_id) === Number(nextStage.season_id) &&\n        !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // Fetch matches for decided stage(s)\n      const matchResults = await Promise.allSettled(\n        stageIdsToUse.map((id) => axios.get(`/api/series/${id}/matches`, { signal: controller.signal }))\n      );\n      const matches = matchResults.flatMap((r) =>\n        r.status === 'fulfilled' ? (r.value.data?.data?.data || []) : []\n      );\n\n      let startMs = null;\n      let endMs = null;\n\n      if (matches.length) {\n        matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n\n        const startDate = new Date(first.starting_at);\n        const endDateObj = extendEndForMatchTypeDate(last.starting_at, last.type) || new Date(last.starting_at);\n\n        startMs = startDate.getTime();\n        endMs = endDateObj.getTime();\n      }\n\n      writeCache(sid, { sid, stageIdsToUse, startMs, endMs });\n\n      if (cancelled) return;\n\n      setSeriesRows((prev) =>\n        prev.map((r) =>\n          r.firstStageId === sid\n            ? {\n                ...r,\n                stage_ids: stageIdsToUse,\n                startDate: startMs != null ? new Date(startMs) : r.startDate,\n                endDate: endMs != null ? new Date(endMs) : r.endDate,\n              }\n            : r\n        )\n      );\n    });\n\n    // Run hydration with high concurrency\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try { await tasks[idx](); } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n\n    run();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n\n  const value = useMemo(\n    () => ({ seriesRows, loadingSeriesRows }),\n    [seriesRows, loadingSeriesRows]\n  );\n\n  return (\n    <SeriesRangesContext.Provider value={value}>\n      {children}\n    </SeriesRangesContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}