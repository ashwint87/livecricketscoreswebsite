{"ast":null,"code":"var _jsxFileName = \"/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/SeriesRangesContext.js\nimport React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeriesRangesContext = /*#__PURE__*/createContext({\n  seriesRows: [],\n  loadingSeriesRows: true\n});\nexport const useSeriesRanges = () => {\n  _s();\n  return useContext(SeriesRangesContext);\n};\n\n/** Cache (bumped version to invalidate old entries) */\n_s(useSeriesRanges, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = sid => `series_range_v3_${sid}`;\n\n/** Helpers */\n_c = CK;\nconst addDaysLocal = (date, days) => {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n};\nconst perMatchExtraDays = (type = '') => {\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') return 4;\n  if (t === '4DAY') return 3;\n  return 0;\n};\nexport function SeriesRangesProvider({\n  children\n}) {\n  _s2();\n  const {\n    allSeries,\n    loading\n  } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map stageId -> base series item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional rows (instant, no network). Hydration will correct them. */\n  const provisionalRows = useMemo(() => {\n    if (!(allSeries !== null && allSeries !== void 0 && allSeries.length)) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Fast guess (validated later by hydration)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext = !!next && Number(next.league_id) === Number(s.league_id) && Number(next.season_id) === Number(s.season_id) && !FORMAT_CODES.includes(code);\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO = (last === null || last === void 0 ? void 0 : last.end_date) || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const startDate = startISO ? new Date(startISO) : null;\n      // provisional end (will be corrected in hydration)\n      const provisionalEnd = endBaseISO ? addDaysLocal(endBaseISO, perMatchExtraDays(last === null || last === void 0 ? void 0 : last.code)) : null;\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate,\n        endDate: provisionalEnd || (endBaseISO ? new Date(endBaseISO) : null)\n      });\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Keep one row per firstStageId for stability\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);else {\n        const cur = uniq.get(r.firstStageId);\n        const better = !cur.startDate && r.startDate || !cur.endDate && r.endDate ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n    return Array.from(uniq.values()).sort((a, b) => {\n      var _a$startDate, _b$startDate;\n      return (((_a$startDate = a.startDate) === null || _a$startDate === void 0 ? void 0 : _a$startDate.getTime()) || 0) - (((_b$startDate = b.startDate) === null || _b$startDate === void 0 ? void 0 : _b$startDate.getTime()) || 0);\n    });\n  }, [allSeries, stageMap]);\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) Hydrate precisely (stage + maybe stage+1 from /api/stages, then matches)\n    const now = Date.now();\n    const readCache = sid => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), {\n          data: parsed.data,\n          exp: parsed.exp\n        });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n    const writeCache = (sid, data) => {\n      const rec = {\n        data,\n        exp: now + TTL_MS\n      };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n    const tasks = provisionalRows.map(row => async () => {\n      var _stageRes$value$data, _stageRes$value$data$, _nextStageRes$value$d, _nextStageRes$value$d2;\n      const sid = row.firstStageId;\n\n      // Use ms in cache to avoid TZ drift\n      const cached = readCache(sid);\n      if ((cached === null || cached === void 0 ? void 0 : cached.startMs) !== undefined && (cached === null || cached === void 0 ? void 0 : cached.endMs) !== undefined && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n          ...r,\n          stage_ids: cached.stageIdsToUse,\n          startDate: cached.startMs !== null ? new Date(cached.startMs) : r.startDate,\n          endDate: cached.endMs !== null ? new Date(cached.endMs) : r.endDate\n        } : r));\n        return;\n      }\n\n      // --- STRICT stage pairing (exactly like SeriesMatchesTab) ---\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([axios.get(`/api/stages/${sid}`, {\n        signal: controller.signal\n      }), axios.get(`/api/stages/${nextId}`, {\n        signal: controller.signal\n      })]);\n      const stage = stageRes.status === 'fulfilled' ? (_stageRes$value$data = stageRes.value.data) === null || _stageRes$value$data === void 0 ? void 0 : (_stageRes$value$data$ = _stageRes$value$data.data) === null || _stageRes$value$data$ === void 0 ? void 0 : _stageRes$value$data$.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? (_nextStageRes$value$d = nextStageRes.value.data) === null || _nextStageRes$value$d === void 0 ? void 0 : (_nextStageRes$value$d2 = _nextStageRes$value$d.data) === null || _nextStageRes$value$d2 === void 0 ? void 0 : _nextStageRes$value$d2.data : null;\n      const includeNext = stage && nextStage && Number(stage.league_id) === Number(nextStage.league_id) && Number(stage.season_id) === Number(nextStage.season_id) && !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // Fetch matches across decided stages\n      const matchResults = await Promise.allSettled(stageIdsToUse.map(id => axios.get(`/api/series/${id}/matches`, {\n        signal: controller.signal\n      })));\n      const matches = matchResults.flatMap(r => {\n        var _r$value$data, _r$value$data$data;\n        return r.status === 'fulfilled' ? ((_r$value$data = r.value.data) === null || _r$value$data === void 0 ? void 0 : (_r$value$data$data = _r$value$data.data) === null || _r$value$data$data === void 0 ? void 0 : _r$value$data$data.data) || [] : [];\n      });\n\n      // Compute start = min(starting_at), end = max(starting_at + extraDaysByType)\n      let startMs = null;\n      let endMs = null;\n      if (matches.length) {\n        let minStart = Infinity;\n        let maxEnd = -Infinity;\n        for (const m of matches) {\n          const start = new Date(m.starting_at);\n          const extra = perMatchExtraDays(m.type);\n          const end = addDaysLocal(start, extra);\n          const sMs = start.getTime();\n          const eMs = end.getTime();\n          if (sMs < minStart) minStart = sMs;\n          if (eMs > maxEnd) maxEnd = eMs;\n        }\n        startMs = isFinite(minStart) ? minStart : null;\n        endMs = isFinite(maxEnd) ? maxEnd : null;\n      }\n      writeCache(sid, {\n        sid,\n        stageIdsToUse,\n        startMs,\n        endMs\n      });\n      if (cancelled) return;\n      setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n        ...r,\n        stage_ids: stageIdsToUse,\n        startDate: startMs !== null ? new Date(startMs) : r.startDate,\n        endDate: endMs !== null ? new Date(endMs) : r.endDate\n      } : r));\n    });\n\n    // High concurrency for quick hydration\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try {\n            await tasks[idx]();\n          } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n    run();\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n  const value = useMemo(() => ({\n    seriesRows,\n    loadingSeriesRows\n  }), [seriesRows, loadingSeriesRows]);\n  return /*#__PURE__*/_jsxDEV(SeriesRangesContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 285,\n    columnNumber: 5\n  }, this);\n}\n_s2(SeriesRangesProvider, \"wYako18W2h16YVYoLOkLbf+W7DM=\", false, function () {\n  return [useSeries];\n});\n_c2 = SeriesRangesProvider;\nvar _c, _c2;\n$RefreshReg$(_c, \"CK\");\n$RefreshReg$(_c2, \"SeriesRangesProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useRef","useState","axios","useSeries","FORMAT_CODES","jsxDEV","_jsxDEV","SeriesRangesContext","seriesRows","loadingSeriesRows","useSeriesRanges","_s","TTL_MS","CK","sid","_c","addDaysLocal","date","days","d","Date","setDate","getDate","perMatchExtraDays","type","t","String","toUpperCase","SeriesRangesProvider","children","_s2","allSeries","loading","setSeriesRows","setLoadingSeriesRows","memCache","Map","stageMap","m","s","Array","isArray","id","Math","min","map","Number","isFinite","set","provisionalRows","length","used","Set","out","sids","from","keys","sort","a","b","has","get","nextId","next","code","includeNext","league_id","season_id","includes","group","stage_ids","startISO","g","start_date","filter","Boolean","last","endBaseISO","end_date","slice","startDate","provisionalEnd","push","base","firstStageId","endDate","add","uniq","r","cur","better","values","_a$startDate","_b$startDate","getTime","cancelled","controller","AbortController","now","readCache","inMem","current","exp","data","raw","localStorage","getItem","parsed","JSON","parse","removeItem","writeCache","rec","setItem","stringify","tasks","row","_stageRes$value$data","_stageRes$value$data$","_nextStageRes$value$d","_nextStageRes$value$d2","cached","startMs","undefined","endMs","stageIdsToUse","prev","stageRes","nextStageRes","Promise","allSettled","signal","stage","status","value","nextStage","matchResults","matches","flatMap","_r$value$data","_r$value$data$data","minStart","Infinity","maxEnd","start","starting_at","extra","end","sMs","eMs","MAX_CONCURRENT","run","i","runners","fill","idx","all","abort","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js"],"sourcesContent":["// src/context/SeriesRangesContext.js\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\n\nconst SeriesRangesContext = createContext({\n  seriesRows: [],\n  loadingSeriesRows: true,\n});\nexport const useSeriesRanges = () => useContext(SeriesRangesContext);\n\n/** Cache (bumped version to invalidate old entries) */\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h\nconst CK = (sid) => `series_range_v3_${sid}`;\n\n/** Helpers */\nconst addDaysLocal = (date, days) => {\n  const d = new Date(date);\n  d.setDate(d.getDate() + days);\n  return d;\n};\nconst perMatchExtraDays = (type = '') => {\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') return 4;\n  if (t === '4DAY') return 3;\n  return 0;\n};\n\nexport function SeriesRangesProvider({ children }) {\n  const { allSeries, loading } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Map stageId -> base series item */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Provisional rows (instant, no network). Hydration will correct them. */\n  const provisionalRows = useMemo(() => {\n    if (!allSeries?.length) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Fast guess (validated later by hydration)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext =\n        !!next &&\n        Number(next.league_id) === Number(s.league_id) &&\n        Number(next.season_id) === Number(s.season_id) &&\n        !FORMAT_CODES.includes(code);\n\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n      const last = group[group.length - 1];\n      const endBaseISO =\n        last?.end_date ||\n        group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] ||\n        null;\n\n      const startDate = startISO ? new Date(startISO) : null;\n      // provisional end (will be corrected in hydration)\n      const provisionalEnd = endBaseISO\n        ? addDaysLocal(endBaseISO, perMatchExtraDays(last?.code))\n        : null;\n\n      out.push({\n        base: s,\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate,\n        endDate: provisionalEnd || (endBaseISO ? new Date(endBaseISO) : null),\n      });\n\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Keep one row per firstStageId for stability\n    const uniq = new Map();\n    for (const r of out) {\n      if (!uniq.has(r.firstStageId)) uniq.set(r.firstStageId, r);\n      else {\n        const cur = uniq.get(r.firstStageId);\n        const better =\n          (!cur.startDate && r.startDate) ||\n          (!cur.endDate && r.endDate) ? r : cur;\n        uniq.set(r.firstStageId, better);\n      }\n    }\n\n    return Array.from(uniq.values()).sort(\n      (a, b) => (a.startDate?.getTime() || 0) - (b.startDate?.getTime() || 0)\n    );\n  }, [allSeries, stageMap]);\n\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false);\n\n    // 2) Hydrate precisely (stage + maybe stage+1 from /api/stages, then matches)\n    const now = Date.now();\n\n    const readCache = (sid) => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), { data: parsed.data, exp: parsed.exp });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n\n    const writeCache = (sid, data) => {\n      const rec = { data, exp: now + TTL_MS };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    const tasks = provisionalRows.map((row) => async () => {\n      const sid = row.firstStageId;\n\n      // Use ms in cache to avoid TZ drift\n      const cached = readCache(sid);\n      if (\n        cached?.startMs !== undefined &&\n        cached?.endMs !== undefined &&\n        Array.isArray(cached.stageIdsToUse)\n      ) {\n        if (cancelled) return;\n        setSeriesRows((prev) =>\n          prev.map((r) =>\n            r.firstStageId === sid\n              ? {\n                  ...r,\n                  stage_ids: cached.stageIdsToUse,\n                  startDate: cached.startMs !== null ? new Date(cached.startMs) : r.startDate,\n                  endDate: cached.endMs !== null ? new Date(cached.endMs) : r.endDate,\n                }\n              : r\n          )\n        );\n        return;\n      }\n\n      // --- STRICT stage pairing (exactly like SeriesMatchesTab) ---\n      const nextId = sid + 1;\n      const [stageRes, nextStageRes] = await Promise.allSettled([\n        axios.get(`/api/stages/${sid}`, { signal: controller.signal }),\n        axios.get(`/api/stages/${nextId}`, { signal: controller.signal }),\n      ]);\n\n      const stage = stageRes.status === 'fulfilled' ? stageRes.value.data?.data?.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? nextStageRes.value.data?.data?.data : null;\n\n      const includeNext =\n        stage &&\n        nextStage &&\n        Number(stage.league_id) === Number(nextStage.league_id) &&\n        Number(stage.season_id) === Number(nextStage.season_id) &&\n        !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n\n      const stageIdsToUse = includeNext ? [sid, nextId] : [sid];\n\n      // Fetch matches across decided stages\n      const matchResults = await Promise.allSettled(\n        stageIdsToUse.map((id) => axios.get(`/api/series/${id}/matches`, { signal: controller.signal }))\n      );\n      const matches = matchResults.flatMap((r) =>\n        r.status === 'fulfilled' ? (r.value.data?.data?.data || []) : []\n      );\n\n      // Compute start = min(starting_at), end = max(starting_at + extraDaysByType)\n      let startMs = null;\n      let endMs = null;\n\n      if (matches.length) {\n        let minStart = Infinity;\n        let maxEnd = -Infinity;\n\n        for (const m of matches) {\n          const start = new Date(m.starting_at);\n          const extra = perMatchExtraDays(m.type);\n          const end = addDaysLocal(start, extra);\n\n          const sMs = start.getTime();\n          const eMs = end.getTime();\n\n          if (sMs < minStart) minStart = sMs;\n          if (eMs > maxEnd) maxEnd = eMs;\n        }\n        startMs = isFinite(minStart) ? minStart : null;\n        endMs = isFinite(maxEnd) ? maxEnd : null;\n      }\n\n      writeCache(sid, { sid, stageIdsToUse, startMs, endMs });\n\n      if (cancelled) return;\n\n      setSeriesRows((prev) =>\n        prev.map((r) =>\n          r.firstStageId === sid\n            ? {\n                ...r,\n                stage_ids: stageIdsToUse,\n                startDate: startMs !== null ? new Date(startMs) : r.startDate,\n                endDate: endMs !== null ? new Date(endMs) : r.endDate,\n              }\n            : r\n        )\n      );\n    });\n\n    // High concurrency for quick hydration\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try { await tasks[idx](); } catch {}\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n\n    run();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n\n  const value = useMemo(\n    () => ({ seriesRows, loadingSeriesRows }),\n    [seriesRows, loadingSeriesRows]\n  );\n\n  return (\n    <SeriesRangesContext.Provider value={value}>\n      {children}\n    </SeriesRangesContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}