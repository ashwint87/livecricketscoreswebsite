{"ast":null,"code":"var _jsxFileName = \"/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/SeriesRangesContext.js\nimport React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeriesRangesContext = /*#__PURE__*/createContext({\n  seriesRows: [],\n  loadingSeriesRows: true\n});\nexport const useSeriesRanges = () => {\n  _s();\n  return useContext(SeriesRangesContext);\n};\n_s(useSeriesRanges, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h cache\nconst CK = sid => `series_range_${sid}`;\n_c = CK;\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\nexport function SeriesRangesProvider({\n  children\n}) {\n  _s2();\n  const {\n    allSeries,\n    loading\n  } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  // Asc stage ids we’ll compute ranges for\n  const stageIdsAsc = useMemo(() => {\n    const ids = new Set();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (sid) ids.add(sid);\n    }\n    return Array.from(ids).sort((a, b) => a - b);\n  }, [allSeries]);\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n    setLoadingSeriesRows(true);\n    const now = Date.now();\n    const readCache = sid => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), {\n          data: parsed.data,\n          exp: parsed.exp\n        });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n    const writeCache = (sid, data) => {\n      const rec = {\n        data,\n        exp: now + TTL_MS\n      };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    // One task per base stage id — EXACTLY mirrors SeriesMatchesTab logic\n    const tasks = stageIdsAsc.map(sid => async () => {\n      var _stageRes$value$data, _stageRes$value$data$, _nextStageRes$value$d, _nextStageRes$value$d2;\n      const cached = readCache(sid);\n      if (cached) return cached;\n      const nextId = sid + 1;\n\n      // stage + (maybe) stage+1 metadata\n      const [stageRes, nextStageRes] = await Promise.allSettled([axios.get(`/api/stages/${sid}`, {\n        signal: controller.signal\n      }), axios.get(`/api/stages/${nextId}`, {\n        signal: controller.signal\n      })]);\n      const stage = stageRes.status === 'fulfilled' ? (_stageRes$value$data = stageRes.value.data) === null || _stageRes$value$data === void 0 ? void 0 : (_stageRes$value$data$ = _stageRes$value$data.data) === null || _stageRes$value$data$ === void 0 ? void 0 : _stageRes$value$data$.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? (_nextStageRes$value$d = nextStageRes.value.data) === null || _nextStageRes$value$d === void 0 ? void 0 : (_nextStageRes$value$d2 = _nextStageRes$value$d.data) === null || _nextStageRes$value$d2 === void 0 ? void 0 : _nextStageRes$value$d2.data : null;\n      let stageIdsToUse = [sid];\n      const includeNext = stage && nextStage && Number(stage.league_id) === Number(nextStage.league_id) && Number(stage.season_id) === Number(nextStage.season_id) && !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n      if (includeNext) stageIdsToUse.push(nextId);\n\n      // Fetch matches for chosen stage(s)\n      const matchResults = await Promise.allSettled(stageIdsToUse.map(id => axios.get(`/api/series/${id}/matches`, {\n        signal: controller.signal\n      })));\n      const matches = matchResults.flatMap(r => {\n        var _r$value$data, _r$value$data$data;\n        return r.status === 'fulfilled' ? ((_r$value$data = r.value.data) === null || _r$value$data === void 0 ? void 0 : (_r$value$data$data = _r$value$data.data) === null || _r$value$data$data === void 0 ? void 0 : _r$value$data$data.data) || [] : [];\n      });\n      matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n      let startDate = null;\n      let endDate = null;\n      if (matches.length) {\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n        startDate = new Date(first.starting_at).toISOString();\n        endDate = extendEndForMatchType(last.starting_at, last.type) || new Date(last.starting_at).toISOString();\n      }\n      const data = {\n        sid,\n        stageIdsToUse,\n        startDate,\n        endDate\n      };\n      writeCache(sid, data);\n      return data;\n    });\n\n    // Run tasks with concurrency limit\n    const MAX_CONCURRENT = 8;\n    const results = new Map();\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          const sid = stageIdsAsc[idx];\n          try {\n            const data = await tasks[idx]();\n            results.set(sid, data);\n          } catch {\n            results.set(sid, {\n              sid,\n              stageIdsToUse: [sid],\n              startDate: null,\n              endDate: null\n            });\n          }\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n    (async () => {\n      await run();\n      if (cancelled) return;\n\n      // Build raw rows from allSeries + computed results\n      const rows = (allSeries || []).map(s => {\n        const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n        const res = results.get(sid);\n        const stage_ids = ((res === null || res === void 0 ? void 0 : res.stageIdsToUse) || (Array.isArray(s.stage_ids) ? s.stage_ids : [sid])).map(Number).sort((a, b) => a - b);\n        return {\n          base: s,\n          firstStageId: sid,\n          season_id: s.season_id,\n          code: s.code,\n          stage_ids,\n          startDate: res !== null && res !== void 0 && res.startDate ? new Date(res.startDate) : null,\n          endDate: res !== null && res !== void 0 && res.endDate ? new Date(res.endDate) : null\n        };\n      });\n\n      // ---- DEDUPE & MERGE (same base + overlapping/adjacent stage ids) ----\n      const baseKeyOf = r => [r.base.league_id, r.base.season_id, String(r.code || '').toUpperCase(), r.base.league, r.base.season].join('::');\n      const intersectOrAdjacent = (aIds, bIds) => {\n        const aSet = new Set(aIds);\n        for (const id of bIds) if (aSet.has(id)) return true; // overlap\n        for (const a of aIds) for (const b of bIds) if (Math.abs(a - b) === 1) return true; // ±1\n        return false;\n      };\n      const mergedMap = new Map();\n      for (const row of rows) {\n        const key = baseKeyOf(row);\n        const existing = mergedMap.get(key);\n        if (!existing) {\n          mergedMap.set(key, {\n            ...row,\n            stage_ids: [...row.stage_ids]\n          });\n          continue;\n        }\n        if (intersectOrAdjacent(existing.stage_ids, row.stage_ids)) {\n          existing.stage_ids = Array.from(new Set([...existing.stage_ids, ...row.stage_ids])).sort((a, b) => a - b);\n          if (!existing.startDate || row.startDate && row.startDate < existing.startDate) existing.startDate = row.startDate;\n          if (!existing.endDate || row.endDate && row.endDate > existing.endDate) existing.endDate = row.endDate;\n          existing.firstStageId = Math.min(existing.firstStageId, row.firstStageId);\n        } else {\n          // Different cluster under the same base: add a suffixed key\n          const altKey = `${key}__${row.firstStageId}`;\n          mergedMap.set(altKey, {\n            ...row,\n            stage_ids: [...row.stage_ids]\n          });\n        }\n      }\n      const mergedList = Array.from(mergedMap.values());\n      mergedList.sort((a, b) => {\n        var _a$startDate, _b$startDate;\n        return (((_a$startDate = a.startDate) === null || _a$startDate === void 0 ? void 0 : _a$startDate.getTime()) || 0) - (((_b$startDate = b.startDate) === null || _b$startDate === void 0 ? void 0 : _b$startDate.getTime()) || 0);\n      });\n      setSeriesRows(mergedList);\n      setLoadingSeriesRows(false);\n    })();\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, allSeries, stageIdsAsc.join(',')]);\n  const value = useMemo(() => ({\n    seriesRows,\n    loadingSeriesRows\n  }), [seriesRows, loadingSeriesRows]);\n  return /*#__PURE__*/_jsxDEV(SeriesRangesContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 238,\n    columnNumber: 5\n  }, this);\n}\n_s2(SeriesRangesProvider, \"5KHDaaNV/lo+V7hurHvHnNAlVO4=\", false, function () {\n  return [useSeries];\n});\n_c2 = SeriesRangesProvider;\nvar _c, _c2;\n$RefreshReg$(_c, \"CK\");\n$RefreshReg$(_c2, \"SeriesRangesProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useRef","useState","axios","useSeries","FORMAT_CODES","jsxDEV","_jsxDEV","SeriesRangesContext","seriesRows","loadingSeriesRows","useSeriesRanges","_s","TTL_MS","CK","sid","_c","extendEndForMatchType","isoStr","type","d","Date","t","String","toUpperCase","setDate","getDate","toISOString","SeriesRangesProvider","children","_s2","allSeries","loading","setSeriesRows","setLoadingSeriesRows","memCache","Map","stageIdsAsc","ids","Set","s","Array","isArray","id","Math","min","map","Number","add","from","sort","a","b","cancelled","controller","AbortController","now","readCache","inMem","current","get","exp","data","raw","localStorage","getItem","parsed","JSON","parse","removeItem","set","writeCache","rec","setItem","stringify","tasks","_stageRes$value$data","_stageRes$value$data$","_nextStageRes$value$d","_nextStageRes$value$d2","cached","nextId","stageRes","nextStageRes","Promise","allSettled","signal","stage","status","value","nextStage","stageIdsToUse","includeNext","league_id","season_id","includes","code","push","matchResults","matches","flatMap","r","_r$value$data","_r$value$data$data","starting_at","startDate","endDate","length","first","last","MAX_CONCURRENT","results","run","i","runners","fill","idx","all","rows","res","stage_ids","base","firstStageId","baseKeyOf","league","season","join","intersectOrAdjacent","aIds","bIds","aSet","has","abs","mergedMap","row","key","existing","altKey","mergedList","values","_a$startDate","_b$startDate","getTime","abort","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js"],"sourcesContent":["// src/context/SeriesRangesContext.js\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\n\nconst SeriesRangesContext = createContext({\n  seriesRows: [],\n  loadingSeriesRows: true,\n});\n\nexport const useSeriesRanges = () => useContext(SeriesRangesContext);\n\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6h cache\nconst CK = (sid) => `series_range_${sid}`;\n\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\nexport function SeriesRangesProvider({ children }) {\n  const { allSeries, loading } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  // Asc stage ids we’ll compute ranges for\n  const stageIdsAsc = useMemo(() => {\n    const ids = new Set();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (sid) ids.add(sid);\n    }\n    return Array.from(ids).sort((a, b) => a - b);\n  }, [allSeries]);\n\n  useEffect(() => {\n    if (loading) return;\n\n    let cancelled = false;\n    const controller = new AbortController();\n    setLoadingSeriesRows(true);\n    const now = Date.now();\n\n    const readCache = (sid) => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), { data: parsed.data, exp: parsed.exp });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n\n    const writeCache = (sid, data) => {\n      const rec = { data, exp: now + TTL_MS };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    // One task per base stage id — EXACTLY mirrors SeriesMatchesTab logic\n    const tasks = stageIdsAsc.map((sid) => async () => {\n      const cached = readCache(sid);\n      if (cached) return cached;\n\n      const nextId = sid + 1;\n\n      // stage + (maybe) stage+1 metadata\n      const [stageRes, nextStageRes] = await Promise.allSettled([\n        axios.get(`/api/stages/${sid}`, { signal: controller.signal }),\n        axios.get(`/api/stages/${nextId}`, { signal: controller.signal }),\n      ]);\n\n      const stage = stageRes.status === 'fulfilled' ? stageRes.value.data?.data?.data : null;\n      const nextStage = nextStageRes.status === 'fulfilled' ? nextStageRes.value.data?.data?.data : null;\n\n      let stageIdsToUse = [sid];\n\n      const includeNext =\n        stage &&\n        nextStage &&\n        Number(stage.league_id) === Number(nextStage.league_id) &&\n        Number(stage.season_id) === Number(nextStage.season_id) &&\n        !FORMAT_CODES.includes(String(stage.code || '').toUpperCase());\n\n      if (includeNext) stageIdsToUse.push(nextId);\n\n      // Fetch matches for chosen stage(s)\n      const matchResults = await Promise.allSettled(\n        stageIdsToUse.map((id) => axios.get(`/api/series/${id}/matches`, { signal: controller.signal }))\n      );\n\n      const matches = matchResults.flatMap((r) =>\n        r.status === 'fulfilled' ? (r.value.data?.data?.data || []) : []\n      );\n\n      matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n\n      let startDate = null;\n      let endDate = null;\n      if (matches.length) {\n        const first = matches[0];\n        const last = matches[matches.length - 1];\n        startDate = new Date(first.starting_at).toISOString();\n        endDate = extendEndForMatchType(last.starting_at, last.type) || new Date(last.starting_at).toISOString();\n      }\n\n      const data = { sid, stageIdsToUse, startDate, endDate };\n      writeCache(sid, data);\n      return data;\n    });\n\n    // Run tasks with concurrency limit\n    const MAX_CONCURRENT = 8;\n    const results = new Map();\n\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          const sid = stageIdsAsc[idx];\n          try {\n            const data = await tasks[idx]();\n            results.set(sid, data);\n          } catch {\n            results.set(sid, { sid, stageIdsToUse: [sid], startDate: null, endDate: null });\n          }\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n\n    (async () => {\n      await run();\n      if (cancelled) return;\n\n      // Build raw rows from allSeries + computed results\n      const rows = (allSeries || []).map((s) => {\n        const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n        const res = results.get(sid);\n        const stage_ids = (res?.stageIdsToUse || (Array.isArray(s.stage_ids) ? s.stage_ids : [sid]))\n          .map(Number)\n          .sort((a, b) => a - b);\n\n        return {\n          base: s,\n          firstStageId: sid,\n          season_id: s.season_id,\n          code: s.code,\n          stage_ids,\n          startDate: res?.startDate ? new Date(res.startDate) : null,\n          endDate: res?.endDate ? new Date(res.endDate) : null,\n        };\n      });\n\n      // ---- DEDUPE & MERGE (same base + overlapping/adjacent stage ids) ----\n      const baseKeyOf = (r) =>\n        [\n          r.base.league_id,\n          r.base.season_id,\n          String(r.code || '').toUpperCase(),\n          r.base.league,\n          r.base.season,\n        ].join('::');\n\n      const intersectOrAdjacent = (aIds, bIds) => {\n        const aSet = new Set(aIds);\n        for (const id of bIds) if (aSet.has(id)) return true; // overlap\n        for (const a of aIds) for (const b of bIds) if (Math.abs(a - b) === 1) return true; // ±1\n        return false;\n      };\n\n      const mergedMap = new Map();\n      for (const row of rows) {\n        const key = baseKeyOf(row);\n        const existing = mergedMap.get(key);\n        if (!existing) {\n          mergedMap.set(key, { ...row, stage_ids: [...row.stage_ids] });\n          continue;\n        }\n        if (intersectOrAdjacent(existing.stage_ids, row.stage_ids)) {\n          existing.stage_ids = Array.from(new Set([...existing.stage_ids, ...row.stage_ids])).sort((a, b) => a - b);\n          if (!existing.startDate || (row.startDate && row.startDate < existing.startDate))\n            existing.startDate = row.startDate;\n          if (!existing.endDate || (row.endDate && row.endDate > existing.endDate))\n            existing.endDate = row.endDate;\n          existing.firstStageId = Math.min(existing.firstStageId, row.firstStageId);\n        } else {\n          // Different cluster under the same base: add a suffixed key\n          const altKey = `${key}__${row.firstStageId}`;\n          mergedMap.set(altKey, { ...row, stage_ids: [...row.stage_ids] });\n        }\n      }\n\n      const mergedList = Array.from(mergedMap.values());\n      mergedList.sort((a, b) => (a.startDate?.getTime() || 0) - (b.startDate?.getTime() || 0));\n\n      setSeriesRows(mergedList);\n      setLoadingSeriesRows(false);\n    })();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, allSeries, stageIdsAsc.join(',')]);\n\n  const value = useMemo(\n    () => ({ seriesRows, loadingSeriesRows }),\n    [seriesRows, loadingSeriesRows]\n  );\n\n  return (\n    <SeriesRangesContext.Provider value={value}>\n      {children}\n    </SeriesRangesContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}