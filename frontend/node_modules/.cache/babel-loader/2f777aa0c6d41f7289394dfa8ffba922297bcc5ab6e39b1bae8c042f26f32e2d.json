{"ast":null,"code":"var _jsxFileName = \"/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/SeriesRangesContext.js\nimport React, { createContext, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SeriesRangesContext = /*#__PURE__*/createContext({\n  seriesRows: [],\n  loadingSeriesRows: true\n});\nexport const useSeriesRanges = () => {\n  _s();\n  return useContext(SeriesRangesContext);\n};\n\n/** Cache */\n_s(useSeriesRanges, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6 hours\nconst CK = sid => `series_range_${sid}`;\n\n/** Extend multi-day finish by match type (precise hydration step) */\n_c = CK;\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\n/** Extend finish by series code (fast provisional step) */\nconst extendEndForSeriesCode = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\nexport function SeriesRangesProvider({\n  children\n}) {\n  _s2();\n  const {\n    allSeries,\n    loading\n  } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n  const memCache = useRef(new Map());\n\n  /** Index series entries by their stage id (id can be number or [ids]) */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Build provisional rows instantly from allSeries (no network) */\n  const provisionalRows = useMemo(() => {\n    if (!(allSeries !== null && allSeries !== void 0 && allSeries.length)) return [];\n    const used = new Set();\n    const out = [];\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n      const s = stageMap.get(sid);\n      if (!s) continue;\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Same rule as tab, but inferred from base objects (no /api/stages)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext = !!next && Number(next.league_id) === Number(s.league_id) && Number(next.season_id) === Number(s.season_id) && !FORMAT_CODES.includes(code);\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      // Provisional range directly from series fields\n      const startISO = group.map(g => g.start_date).filter(Boolean).sort()[0] || null;\n\n      // End uses the *last group's* end_date and its code for multi-day extension\n      const last = group[group.length - 1];\n      const endBaseISO = (last === null || last === void 0 ? void 0 : last.end_date) || group.map(g => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const endISO = extendEndForSeriesCode(endBaseISO, last === null || last === void 0 ? void 0 : last.code) || endBaseISO;\n      out.push({\n        base: s,\n        // keep first for naming\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate: startISO ? new Date(startISO) : null,\n        endDate: endISO ? new Date(endISO) : null\n      });\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Dedupe/merge clusters with same base (league/season/code) that overlap/adjacent\n    const baseKey = r => [r.base.league_id, r.base.season_id, String(r.code || '').toUpperCase(), r.base.league, r.base.season].join('::');\n    const intersectOrAdjacent = (aIds, bIds) => {\n      const aSet = new Set(aIds);\n      for (const id of bIds) if (aSet.has(id)) return true;\n      for (const a of aIds) for (const b of bIds) if (Math.abs(a - b) === 1) return true;\n      return false;\n    };\n    const merged = new Map();\n    for (const row of out) {\n      const key = baseKey(row);\n      const exist = merged.get(key);\n      if (!exist) {\n        merged.set(key, {\n          ...row,\n          stage_ids: [...row.stage_ids]\n        });\n      } else if (intersectOrAdjacent(exist.stage_ids, row.stage_ids)) {\n        exist.stage_ids = Array.from(new Set([...exist.stage_ids, ...row.stage_ids])).sort((a, b) => a - b);\n        if (!exist.startDate || row.startDate && row.startDate < exist.startDate) exist.startDate = row.startDate;\n        if (!exist.endDate || row.endDate && row.endDate > exist.endDate) exist.endDate = row.endDate;\n        exist.firstStageId = Math.min(exist.firstStageId, row.firstStageId);\n      } else {\n        merged.set(`${key}__${row.firstStageId}`, {\n          ...row,\n          stage_ids: [...row.stage_ids]\n        });\n      }\n    }\n    const list = Array.from(merged.values());\n    list.sort((a, b) => {\n      var _a$startDate, _b$startDate;\n      return (((_a$startDate = a.startDate) === null || _a$startDate === void 0 ? void 0 : _a$startDate.getTime()) || 0) - (((_b$startDate = b.startDate) === null || _b$startDate === void 0 ? void 0 : _b$startDate.getTime()) || 0);\n    });\n    return list;\n  }, [allSeries, stageMap]);\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly with provisional list\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false); // allow page to render immediately\n\n    // 2) Hydrate precisely in the background (matches-derived, cached)\n    const now = Date.now();\n    const readCache = sid => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), {\n          data: parsed.data,\n          exp: parsed.exp\n        });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n    const writeCache = (sid, data) => {\n      const rec = {\n        data,\n        exp: now + TTL_MS\n      };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    // Build hydration tasks (skip if fully cached)\n    const tasks = provisionalRows.map(row => async () => {\n      const sid = row.firstStageId;\n      const cached = readCache(sid);\n      if (cached !== null && cached !== void 0 && cached.startDate && cached !== null && cached !== void 0 && cached.endDate && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        // Update only if it differs from current\n        setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n          ...r,\n          stage_ids: cached.stageIdsToUse,\n          startDate: new Date(cached.startDate),\n          endDate: new Date(cached.endDate)\n        } : r));\n        return;\n      }\n\n      // Infer the exact stage set we should hydrate (row.stage_ids is already correct)\n      const stageIdsToUse = row.stage_ids;\n\n      // Fetch matches for those stages\n      const matchResults = await Promise.allSettled(stageIdsToUse.map(id => axios.get(`/api/series/${id}/matches`, {\n        signal: controller.signal\n      })));\n      const matches = matchResults.flatMap(r => {\n        var _r$value$data, _r$value$data$data;\n        return r.status === 'fulfilled' ? ((_r$value$data = r.value.data) === null || _r$value$data === void 0 ? void 0 : (_r$value$data$data = _r$value$data.data) === null || _r$value$data$data === void 0 ? void 0 : _r$value$data$data.data) || [] : [];\n      });\n      if (!matches.length) {\n        writeCache(sid, {\n          sid,\n          stageIdsToUse,\n          startDate: null,\n          endDate: null\n        });\n        return;\n      }\n      matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n      const first = matches[0];\n      const last = matches[matches.length - 1];\n      const startDateISO = new Date(first.starting_at).toISOString();\n      const endDateISO = extendEndForMatchType(last.starting_at, last.type) || new Date(last.starting_at).toISOString();\n      writeCache(sid, {\n        sid,\n        stageIdsToUse,\n        startDate: startDateISO,\n        endDate: endDateISO\n      });\n      if (cancelled) return;\n\n      // Update the row in place\n      setSeriesRows(prev => prev.map(r => r.firstStageId === sid ? {\n        ...r,\n        startDate: new Date(startDateISO),\n        endDate: new Date(endDateISO)\n      } : r));\n    });\n\n    // Run with higher concurrency so hydration finishes quickly\n    const MAX_CONCURRENT = 24;\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try {\n            await tasks[idx]();\n          } catch {\n            // ignore individual failures\n          }\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n    run();\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n  const value = useMemo(() => ({\n    seriesRows,\n    loadingSeriesRows\n  }), [seriesRows, loadingSeriesRows]);\n  return /*#__PURE__*/_jsxDEV(SeriesRangesContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 281,\n    columnNumber: 5\n  }, this);\n}\n_s2(SeriesRangesProvider, \"wYako18W2h16YVYoLOkLbf+W7DM=\", false, function () {\n  return [useSeries];\n});\n_c2 = SeriesRangesProvider;\nvar _c, _c2;\n$RefreshReg$(_c, \"CK\");\n$RefreshReg$(_c2, \"SeriesRangesProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useMemo","useRef","useState","axios","useSeries","FORMAT_CODES","jsxDEV","_jsxDEV","SeriesRangesContext","seriesRows","loadingSeriesRows","useSeriesRanges","_s","TTL_MS","CK","sid","_c","extendEndForMatchType","isoStr","type","d","Date","t","String","toUpperCase","setDate","getDate","toISOString","extendEndForSeriesCode","code","c","SeriesRangesProvider","children","_s2","allSeries","loading","setSeriesRows","setLoadingSeriesRows","memCache","Map","stageMap","m","s","Array","isArray","id","Math","min","map","Number","isFinite","set","provisionalRows","length","used","Set","out","sids","from","keys","sort","a","b","has","get","nextId","next","includeNext","league_id","season_id","includes","group","stage_ids","startISO","g","start_date","filter","Boolean","last","endBaseISO","end_date","slice","endISO","push","base","firstStageId","startDate","endDate","add","baseKey","r","league","season","join","intersectOrAdjacent","aIds","bIds","aSet","abs","merged","row","key","exist","list","values","_a$startDate","_b$startDate","getTime","cancelled","controller","AbortController","now","readCache","inMem","current","exp","data","raw","localStorage","getItem","parsed","JSON","parse","removeItem","writeCache","rec","setItem","stringify","tasks","cached","stageIdsToUse","prev","matchResults","Promise","allSettled","signal","matches","flatMap","_r$value$data","_r$value$data$data","status","value","starting_at","first","startDateISO","endDateISO","MAX_CONCURRENT","run","i","runners","fill","idx","all","abort","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["/Users/ashwin.r1/Downloads/live-cricket-scores-main/frontend/src/context/SeriesRangesContext.js"],"sourcesContent":["// src/context/SeriesRangesContext.js\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport axios from 'axios';\nimport { useSeries } from './SeriesContext';\nimport { FORMAT_CODES } from '../constants/matchStatusConstants';\n\nconst SeriesRangesContext = createContext({\n  seriesRows: [],\n  loadingSeriesRows: true,\n});\n\nexport const useSeriesRanges = () => useContext(SeriesRangesContext);\n\n/** Cache */\nconst TTL_MS = 6 * 60 * 60 * 1000; // 6 hours\nconst CK = (sid) => `series_range_${sid}`;\n\n/** Extend multi-day finish by match type (precise hydration step) */\nconst extendEndForMatchType = (isoStr, type = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const t = String(type || '').toUpperCase();\n  if (t === 'TEST' || t === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (t === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\n/** Extend finish by series code (fast provisional step) */\nconst extendEndForSeriesCode = (isoStr, code = '') => {\n  if (!isoStr) return null;\n  const d = new Date(isoStr);\n  const c = String(code || '').toUpperCase();\n  if (c === 'TEST' || c === 'TEST/5DAY') d.setDate(d.getDate() + 4);\n  else if (c === '4DAY') d.setDate(d.getDate() + 3);\n  return d.toISOString();\n};\n\nexport function SeriesRangesProvider({ children }) {\n  const { allSeries, loading } = useSeries();\n  const [seriesRows, setSeriesRows] = useState([]);\n  const [loadingSeriesRows, setLoadingSeriesRows] = useState(true);\n\n  const memCache = useRef(new Map());\n\n  /** Index series entries by their stage id (id can be number or [ids]) */\n  const stageMap = useMemo(() => {\n    const m = new Map();\n    for (const s of allSeries || []) {\n      const sid = Array.isArray(s.id) ? Math.min(...s.id.map(Number)) : Number(s.id);\n      if (!Number.isFinite(sid)) continue;\n      m.set(sid, s);\n    }\n    return m;\n  }, [allSeries]);\n\n  /** Build provisional rows instantly from allSeries (no network) */\n  const provisionalRows = useMemo(() => {\n    if (!allSeries?.length) return [];\n\n    const used = new Set();\n    const out = [];\n\n    const sids = Array.from(stageMap.keys()).sort((a, b) => a - b);\n\n    for (const sid of sids) {\n      if (used.has(sid)) continue;\n\n      const s = stageMap.get(sid);\n      if (!s) continue;\n\n      const nextId = sid + 1;\n      const next = stageMap.get(nextId);\n\n      // Same rule as tab, but inferred from base objects (no /api/stages)\n      const code = String(s.code || '').toUpperCase();\n      const includeNext =\n        !!next &&\n        Number(next.league_id) === Number(s.league_id) &&\n        Number(next.season_id) === Number(s.season_id) &&\n        !FORMAT_CODES.includes(code);\n\n      const group = includeNext ? [s, next] : [s];\n      const stage_ids = includeNext ? [sid, nextId] : [sid];\n\n      // Provisional range directly from series fields\n      const startISO = group\n        .map((g) => g.start_date)\n        .filter(Boolean)\n        .sort()[0] || null;\n\n      // End uses the *last group's* end_date and its code for multi-day extension\n      const last = group[group.length - 1];\n      const endBaseISO = last?.end_date || group.map((g) => g.end_date).filter(Boolean).sort().slice(-1)[0] || null;\n      const endISO = extendEndForSeriesCode(endBaseISO, last?.code) || endBaseISO;\n\n      out.push({\n        base: s, // keep first for naming\n        firstStageId: sid,\n        season_id: s.season_id,\n        code: s.code,\n        stage_ids,\n        startDate: startISO ? new Date(startISO) : null,\n        endDate: endISO ? new Date(endISO) : null,\n      });\n\n      used.add(sid);\n      if (includeNext) used.add(nextId);\n    }\n\n    // Dedupe/merge clusters with same base (league/season/code) that overlap/adjacent\n    const baseKey = (r) =>\n      [r.base.league_id, r.base.season_id, String(r.code || '').toUpperCase(), r.base.league, r.base.season].join('::');\n\n    const intersectOrAdjacent = (aIds, bIds) => {\n      const aSet = new Set(aIds);\n      for (const id of bIds) if (aSet.has(id)) return true;\n      for (const a of aIds) for (const b of bIds) if (Math.abs(a - b) === 1) return true;\n      return false;\n    };\n\n    const merged = new Map();\n    for (const row of out) {\n      const key = baseKey(row);\n      const exist = merged.get(key);\n      if (!exist) {\n        merged.set(key, { ...row, stage_ids: [...row.stage_ids] });\n      } else if (intersectOrAdjacent(exist.stage_ids, row.stage_ids)) {\n        exist.stage_ids = Array.from(new Set([...exist.stage_ids, ...row.stage_ids])).sort((a, b) => a - b);\n        if (!exist.startDate || (row.startDate && row.startDate < exist.startDate)) exist.startDate = row.startDate;\n        if (!exist.endDate || (row.endDate && row.endDate > exist.endDate)) exist.endDate = row.endDate;\n        exist.firstStageId = Math.min(exist.firstStageId, row.firstStageId);\n      } else {\n        merged.set(`${key}__${row.firstStageId}`, { ...row, stage_ids: [...row.stage_ids] });\n      }\n    }\n\n    const list = Array.from(merged.values());\n    list.sort((a, b) => (a.startDate?.getTime() || 0) - (b.startDate?.getTime() || 0));\n    return list;\n  }, [allSeries, stageMap]);\n\n  useEffect(() => {\n    if (loading) return;\n    let cancelled = false;\n    const controller = new AbortController();\n\n    // 1) Paint instantly with provisional list\n    setSeriesRows(provisionalRows);\n    setLoadingSeriesRows(false); // allow page to render immediately\n\n    // 2) Hydrate precisely in the background (matches-derived, cached)\n    const now = Date.now();\n\n    const readCache = (sid) => {\n      const inMem = memCache.current.get(String(sid));\n      if (inMem && inMem.exp > now) return inMem.data;\n      try {\n        const raw = localStorage.getItem(CK(sid));\n        if (!raw) return null;\n        const parsed = JSON.parse(raw);\n        if (!parsed || parsed.exp <= now) {\n          localStorage.removeItem(CK(sid));\n          return null;\n        }\n        memCache.current.set(String(sid), { data: parsed.data, exp: parsed.exp });\n        return parsed.data;\n      } catch {\n        return null;\n      }\n    };\n\n    const writeCache = (sid, data) => {\n      const rec = { data, exp: now + TTL_MS };\n      memCache.current.set(String(sid), rec);\n      try {\n        localStorage.setItem(CK(sid), JSON.stringify(rec));\n      } catch {}\n    };\n\n    // Build hydration tasks (skip if fully cached)\n    const tasks = provisionalRows.map((row) => async () => {\n      const sid = row.firstStageId;\n      const cached = readCache(sid);\n      if (cached?.startDate && cached?.endDate && Array.isArray(cached.stageIdsToUse)) {\n        if (cancelled) return;\n        // Update only if it differs from current\n        setSeriesRows((prev) =>\n          prev.map((r) =>\n            r.firstStageId === sid\n              ? {\n                  ...r,\n                  stage_ids: cached.stageIdsToUse,\n                  startDate: new Date(cached.startDate),\n                  endDate: new Date(cached.endDate),\n                }\n              : r\n          )\n        );\n        return;\n      }\n\n      // Infer the exact stage set we should hydrate (row.stage_ids is already correct)\n      const stageIdsToUse = row.stage_ids;\n\n      // Fetch matches for those stages\n      const matchResults = await Promise.allSettled(\n        stageIdsToUse.map((id) => axios.get(`/api/series/${id}/matches`, { signal: controller.signal }))\n      );\n      const matches = matchResults.flatMap((r) =>\n        r.status === 'fulfilled' ? (r.value.data?.data?.data || []) : []\n      );\n\n      if (!matches.length) {\n        writeCache(sid, { sid, stageIdsToUse, startDate: null, endDate: null });\n        return;\n      }\n\n      matches.sort((a, b) => new Date(a.starting_at) - new Date(b.starting_at));\n      const first = matches[0];\n      const last = matches[matches.length - 1];\n\n      const startDateISO = new Date(first.starting_at).toISOString();\n      const endDateISO =\n        extendEndForMatchType(last.starting_at, last.type) ||\n        new Date(last.starting_at).toISOString();\n\n      writeCache(sid, { sid, stageIdsToUse, startDate: startDateISO, endDate: endDateISO });\n\n      if (cancelled) return;\n\n      // Update the row in place\n      setSeriesRows((prev) =>\n        prev.map((r) =>\n          r.firstStageId === sid\n            ? { ...r, startDate: new Date(startDateISO), endDate: new Date(endDateISO) }\n            : r\n        )\n      );\n    });\n\n    // Run with higher concurrency so hydration finishes quickly\n    const MAX_CONCURRENT = 24;\n\n    const run = async () => {\n      let i = 0;\n      const runners = new Array(Math.min(MAX_CONCURRENT, tasks.length)).fill(0).map(async () => {\n        while (i < tasks.length) {\n          const idx = i++;\n          try {\n            await tasks[idx]();\n          } catch {\n            // ignore individual failures\n          }\n          if (cancelled) return;\n        }\n      });\n      await Promise.all(runners);\n    };\n\n    run();\n\n    return () => {\n      cancelled = true;\n      controller.abort();\n    };\n  }, [loading, provisionalRows]);\n\n  const value = useMemo(\n    () => ({ seriesRows, loadingSeriesRows }),\n    [seriesRows, loadingSeriesRows]\n  );\n\n  return (\n    <SeriesRangesContext.Provider value={value}>\n      {children}\n    </SeriesRangesContext.Provider>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}